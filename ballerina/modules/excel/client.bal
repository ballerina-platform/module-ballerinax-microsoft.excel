// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;

# Ballerina Microsoft Excel client provides the capability to access Microsoft Graph Excel API to perform CRUD (Create, Read, Update, and Delete) operations on Excel workbooks stored in Microsoft OneDrive for Business, SharePoint site or Group drive.
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://graph.microsoft.com/v1.0/") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        http:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }
    # Creates a new session for a workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + return - OK 
    remote isolated function createSession(string itemId, Session payload) returns Session|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/createSession`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Session response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Refresh the existing workbook session..
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function refreshSession(string itemId, string sessionId) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/refreshSession`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Close the existing workbook session.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function closeSession(string itemId, string sessionId) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/closeSession`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Creates a new session for a workbook.
    #
    # + itemPath - The full path of the workbook
    # + return - OK 
    remote isolated function createSessionWithItemPath(string itemPath, Session payload) returns Session|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/createSession`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Session response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Refresh the existing workbook session..
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function refreshSessionWithItemPath(string itemPath, string sessionId) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/refreshSession`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Close an existing workbook session.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function closeSessionWithItemPath(string itemPath, string sessionId) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/closeSession`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Recalculate all currently opened workbooks in Excel.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function calculateApplication(string itemId, CalculationMode payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/application/calculate`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Get the properties and relationships of the application.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getApplication(string itemId, string? sessionId = ()) returns Application|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/application`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Application response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Recalculate all currently opened workbooks in Excel.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function calculateApplicationWithItemPath(string itemPath, CalculationMode payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/application/calculate`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Get the properties and relationships of the application.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getApplicationWithItemPath(string itemPath, string? sessionId = ()) returns Application|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/application`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Application response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of comment.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function listComments(string itemId, string? sessionId = ()) returns Comments|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/comments`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Comments response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the comment.
    #
    # + itemId - The ID of the drive containing the workbook
    # + commentId - The ID of the comment to get
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getComment(string itemId, string commentId, string? sessionId = ()) returns Comment|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/comments/${getEncodedUri(commentId)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Comment response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List the replies of the comment.
    #
    # + itemId - The ID of the drive containing the workbook
    # + commentId - The ID of the comment to get
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function listCommentReplies(string itemId, string commentId, string? sessionId = ()) returns Replies|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/comments/${getEncodedUri(commentId)}/replies`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Replies response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a new reply of the comment.
    #
    # + itemId - The ID of the drive containing the workbook
    # + commentId - The ID of the comment to get
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function createCommentReply(string itemId, string commentId, Reply payload, string? sessionId = ()) returns Reply|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/comments/${getEncodedUri(commentId)}/replies`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Reply response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the reply.
    #
    # + itemId - The ID of the drive containing the workbook
    # + commentId - The ID of the comment to get
    # + replyId - The ID of the reply
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getCommentReply(string itemId, string commentId, string replyId, string? sessionId = ()) returns Reply|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/comments/${getEncodedUri(commentId)}/replies/${getEncodedUri(replyId)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Reply response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of comment.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function listCommentsWithItemPath(string itemPath, string? sessionId = ()) returns Comments|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/comments`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Comments response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the comment.
    #
    # + itemPath - The full path of the workbook
    # + commentId - The ID of the comment to get
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCommentWithItemPath(string itemPath, string commentId, string? sessionId = ()) returns Comment|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/comments/${getEncodedUri(commentId)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Comment response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List the replies of the comment.
    #
    # + itemPath - The full path of the workbook
    # + commentId - The ID of the comment to get
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function listCommentRepliesWithItemPath(string itemPath, string commentId, string? sessionId = ()) returns Replies|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/comments/${getEncodedUri(commentId)}/replies`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Replies response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a new reply of the comment.
    #
    # + itemPath - The full path of the workbook
    # + commentId - The ID of the comment to get
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function createCommentReplyWithItemPath(string itemPath, string commentId, Reply payload, string? sessionId = ()) returns Reply|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/comments/${getEncodedUri(commentId)}/replies`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Reply response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the reply.
    #
    # + itemPath - The full path of the workbook
    # + commentId - The ID of the comment to get
    # + replyId - The ID of the reply
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getCommentReplyWithItemPath(string itemPath, string commentId, string replyId, string? sessionId = ()) returns Reply|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/comments/${getEncodedUri(commentId)}/replies/${getEncodedUri(replyId)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Reply response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listWorksheets(string itemId, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Worksheets|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Worksheets response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Adds a new worksheet to the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function addWorksheet(string itemId, CreateWorksheet payload, string? sessionId = ()) returns Worksheet|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Worksheet response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getWorksheet(string itemId, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Worksheet|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Worksheet response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Worksheet
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function deleteWorksheet(string itemId, string worksheetIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update the properties of worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - Success. 
    remote isolated function updateWorksheet(string itemId, string worksheetIdOrName, Worksheet payload, string? sessionId = ()) returns Worksheet|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Worksheet response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Get the used range of a worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getUsedRange(string itemId, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/usedRange`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range containing the single cell based on row and column numbers.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getRangeWithRowAndColumn(string itemId, string worksheetIdOrName, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of workbook pivottable.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function listPivotTable(string itemId, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns PivotTables|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/pivotTables`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        PivotTables response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of pivot table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + pivotTableId - The ID of the pivot table.
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getPivotTable(string itemId, string worksheetIdOrName, string pivotTableId, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns PivotTable|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/pivotTables/${getEncodedUri(pivotTableId)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        PivotTable response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Refreshes the pivot table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + pivotTableId - The ID of the pivot table.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function refreshPivotTable(string itemId, string worksheetIdOrName, string pivotTableId, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/pivotTables/${getEncodedUri(pivotTableId)}/refresh`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Refreshes the pivot table within a given worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + pivotTableId - The ID of the pivot table.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function refreshAllPivotTable(string itemId, string worksheetIdOrName, string pivotTableId, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/pivotTables/${getEncodedUri(pivotTableId)}/refreshAll`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve a list of worksheet.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listWorksheetsWithIemPath(string itemPath, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Worksheets|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Worksheets response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Adds a new worksheet to the workbook.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function addWorksheetWithIemPath(string itemPath, CreateWorksheet payload, string? sessionId = ()) returns Worksheet|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Worksheet response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getWorksheetWithIemPath(string itemPath, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Worksheet|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Worksheet response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Worksheet
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function deleteWorksheetWithIemPath(string itemPath, string worksheetIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update the properties of worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - Success. 
    remote isolated function updateWorksheetWithIemPath(string itemPath, string worksheetIdOrName, Worksheet payload, string? sessionId = ()) returns Worksheet|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Worksheet response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Get the used range of a worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getUsedRangeWithIemPath(string itemPath, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/usedRange`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range containing the single cell based on row and column numbers.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getRangeWithRowAndColumnWithItemPath(string itemPath, string worksheetIdOrName, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of workbook pivottable.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function listPivotTableWithItemPath(string itemPath, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns PivotTables|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/pivotTables`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        PivotTables response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of workbook pivottable.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + pivotTableId - The ID of the pivot table.
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getPivotTableWithItemPath(string itemPath, string worksheetIdOrName, string pivotTableId, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns PivotTable|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/pivotTables/${getEncodedUri(pivotTableId)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        PivotTable response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Refreshes the pivot table.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + pivotTableId - The ID of the pivot table.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function refreshPivotTableWithItemPath(string itemPath, string worksheetIdOrName, string pivotTableId, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/pivotTables/${getEncodedUri(pivotTableId)}/refresh`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Refreshes the pivot table within a given worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + pivotTableId - The ID of the pivot table.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function refreshAllPivotTableWithItemPath(string itemPath, string worksheetIdOrName, string pivotTableId, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/pivotTables/${getEncodedUri(pivotTableId)}/refreshAll`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Gets the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getWorksheetRange(string itemId, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateRange(string itemId, string namedItemName, Range payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - Success. 
    remote isolated function getRangeWithAddress(string itemId, string worksheetIdOrName, string address, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateRangeWithAddress(string itemId, string worksheetIdOrName, string address, Range payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + address - The address
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - Success. 
    remote isolated function getColumnRange(string itemId, string tableIdOrName, string columnIdOrName, string address, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateColumnRange(string itemId, string tableIdOrName, string columnIdOrName, Range payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Inserts a cell or a range of cells into the worksheet in place of this range, and shifts the other cells to make space.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function insertRange(string itemId, string namedItemName, Shift payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/insert`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Inserts a cell or a range of cells into the worksheet in place of this range, and shifts the other cells to make space.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function insertRangeWithAddrees(string itemId, string worksheetIdOrName, string address, Shift payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/insert`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Inserts a cell or a range of cells into the worksheet in place of this range, and shifts the other cells to make space.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function insertColumnRange(string itemId, string tableIdOrName, string columnIdOrName, Shift payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/insert`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the range format
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function getRangeFormat(string itemId, string namedItemName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/format`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RangeFormat response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range format.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateRangeFormat(string itemId, string namedItemName, RangeFormat payload, string? sessionId = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/format`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RangeFormat response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the range format
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function getRangeFormatWithAddress(string itemId, string worksheetIdOrName, string address, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/format`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RangeFormat response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range format.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateRangeFormatWithAddress(string itemId, string worksheetIdOrName, string address, RangeFormat payload, string? sessionId = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/format`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RangeFormat response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the range format
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function getColumnRangeFormat(string itemId, string tableIdOrName, string columnIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/format`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RangeFormat response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range format.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateColumnRangeFormat(string itemId, string tableIdOrName, string columnIdOrName, RangeFormat payload, string? sessionId = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/format`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RangeFormat response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Merge the range cells into one region in the worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function mergeRange(string itemId, string namedItemName, Across payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/merge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Merge the range cells into one region in the worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function mergeRangeWithAddress(string itemId, string worksheetIdOrName, string address, Across payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/merge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Merge the range cells into one region in the worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function mergeColumnRange(string itemId, string tableIdOrName, string columnIdOrName, Across payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/merge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Unmerge the range cells into separate cells.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function unmergeRange(string itemId, string namedItemName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/unmerge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Unmerge the range cells into separate cells.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function unmergeRangeWithAddress(string itemId, string worksheetIdOrName, string address, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/unmerge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Unmerge the range cells into separate cells.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function unmergeColumnRange(string itemId, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/unmerge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Clear range values such as format, fill, and border.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function clearRange(string itemId, string namedItemName, ApplyTo payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/clear`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Clear range values such as format, fill, and border.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function clearRangeWithAddress(string itemId, string worksheetIdOrName, string address, ApplyTo payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/clear`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Clear range values such as format, fill, and border.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function clearColumnRange(string itemId, string tableIdOrName, string columnIdOrName, ApplyTo payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/clear`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the cells associated with the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteCell(string itemId, string namedItemName, Shift payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/delete`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the cells associated with the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteCellWithAddress(string itemId, string worksheetIdOrName, string address, Shift payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/delete`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the cells associated with the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteColumnCell(string itemId, string tableIdOrName, string columnIdOrName, Shift payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/delete`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Gets the range containing the single cell based on row and column numbers.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getNameRangeWithRowAndColumn(string itemId, string namedItemName, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range object containing the single cell based on row and column numbers.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getWorkSheetRangeWithRowAndColumn(string itemId, string worksheetIdOrName, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range object containing the single cell based on row and column numbers.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRangeWithRowColumnAddress(string itemId, string worksheetIdOrName, string address, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range object containing the single cell based on row and column numbers.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnRangeWithRowAndColumn(string itemId, string tableIdOrName, string columnIdOrName, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a column contained in the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRangeColumn(string itemId, string namedItemName, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/column(column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a column contained in the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRangeColumnWithAddress(string itemId, string worksheetIdOrName, string address, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/column(column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a column contained in the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnRangeColumn(string itemId, string tableIdOrName, string columnIdOrName, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/column(column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the right of the given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCloumAfterRange(string itemId, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/columnsAfter`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the right of the given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + columnCount - The number of columns to include in the resulting range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCloumAfterRangeWithCount(string itemId, string worksheetIdOrName, int columnCount, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/columnsAfter(count=${getEncodedUri(columnCount)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the left of the given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCloumBeforeRange(string itemId, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/columnsBefore`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the left of the given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + columnCount - The number of columns to include in the resulting range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCloumBeforeRangeWithCount(string itemId, string worksheetIdOrName, int columnCount, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/columnsBefore(count=${getEncodedUri(columnCount)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire column of the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getEntireColumnRange(string itemId, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/entireColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire column of the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getEntireColumnRangeWithAddress(string itemId, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/entireColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire column of the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getColumnEntireColumnRange(string itemId, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/entireColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire row of the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getEntireRowRange(string itemId, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/entireRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire row of the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getEntireRowRangeWithAddress(string itemId, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/entireRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire row of the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnEntireRowRange(string itemId, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/entireRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last cell within the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastCell(string itemId, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/lastCell`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last cell within the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastCellWithAddress(string itemId, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/lastCell`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last cell within the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnLastCell(string itemId, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/lastCell`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last column within the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastColumnRange(string itemId, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/lastColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last column within the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastColumnRangeWithAddress(string itemId, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/lastColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last column within the range
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnLastColumnRange(string itemId, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/lastColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last row within the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastRowRange(string itemId, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/lastRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last row within the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastRowRangeWithAddress(string itemId, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/lastRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last row within the range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnLastRowRange(string itemId, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/lastRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of rows above a given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRowsAboveRange(string itemId, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/rowsAbove`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of rows above a given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + rowCount - The number of rows to include in the resulting range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRowsAboveRangeWithCount(string itemId, string worksheetIdOrName, int rowCount, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/rowsAbove(count=${getEncodedUri(rowCount)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the left of the given range
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRowsBelowRange(string itemId, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/rowsBelow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the left of the given range
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + rowCount - The number of rows to include in the resulting range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRowsBelowRangeWithCount(string itemId, string worksheetIdOrName, int rowCount, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/rowsBelow(count=${getEncodedUri(rowCount)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the used range of the given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + namedItemName - The name of the named item
    # + valuesOnly - A value indicating whether to return only the values in the used range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getUsedRangeWithValuesOnly(string itemId, string namedItemName, boolean valuesOnly, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(namedItemName)}/range/usedRange(valuesOnly=${getEncodedUri(valuesOnly)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the used range of the given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + valuesOnly - A value indicating whether to return only the values in the used range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getUsedRangeWithAddress(string itemId, string worksheetIdOrName, string address, boolean valuesOnly, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/usedRange(valuesOnly=${getEncodedUri(valuesOnly)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the used range of the given range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + valuesOnly - A value indicating whether to return only the values in the used range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnUsedRange(string itemId, string tableIdOrName, string columnIdOrName, boolean valuesOnly, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/usedRange(valuesOnly=${getEncodedUri(valuesOnly)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the resized range of a range.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + deltaRows - The number of rows to expand or contract the bottom-right corner of the range by. If deltaRows is positive, the range will be expanded. If deltaRows is negative, the range will be contracted.
    # + deltaColumns - The number of columns to expand or contract the bottom-right corner of the range by. If deltaColumns is positive, the range will be expanded. If deltaColumns is negative, the range will be contracted.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getResizedRange(string itemId, string worksheetIdOrName, int deltaRows, int deltaColumns, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/resizedRange(deltaRows=${getEncodedUri(deltaRows)}, deltaColumns=${getEncodedUri(deltaColumns)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        Range response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Get the range visible from a filtered range
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getVisibleView(string itemId, string worksheetIdOrName, string address, string? sessionId = ()) returns RangeView|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/visibleView`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RangeView response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getWorksheetRangeWithItemPath(string itemPath, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateWorkbookRangeWithItemPath(string itemPath, string namedItemName, Range payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - Success. 
    remote isolated function getRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, Range payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of range.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + address - The address
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - Success. 
    remote isolated function getColumnRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string address, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateColumnRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, Range payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Inserts a cell or a range of cells into the worksheet in place of this range, and shifts the other cells to make space.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function insertRangeWithItemPath(string itemPath, string namedItemName, Shift payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/insert`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Inserts a cell or a range of cells into the worksheet in place of this range, and shifts the other cells to make space.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function insertRangeWithAddreesItemPath(string itemPath, string worksheetIdOrName, string address, Shift payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/insert`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Inserts a cell or a range of cells into the worksheet in place of this range, and shifts the other cells to make space.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function insertColumnRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, Shift payload, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/insert`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Range response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the range format
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function getRangeFormatWithItemPath(string itemPath, string namedItemName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/format`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RangeFormat response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range format.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateRangeFormatWithItemPath(string itemPath, string namedItemName, RangeFormat payload, string? sessionId = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/format`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RangeFormat response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the range format
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function getRangeFormatWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/format`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RangeFormat response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range format.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateRangeFormatWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, RangeFormat payload, string? sessionId = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/format`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RangeFormat response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the range format
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function getColumnRangeFormatWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/format`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RangeFormat response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of range format.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateColumnRangeFormatWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, RangeFormat payload, string? sessionId = ()) returns RangeFormat|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/format`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        RangeFormat response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Merge the range cells into one region in the worksheet.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function mergeRangeWithItemPath(string itemPath, string namedItemName, Across payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/merge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Merge the range cells into one region in the worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function mergeRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, Across payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/merge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Merge the range cells into one region in the worksheet.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function mergeColumnRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, Across payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/merge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Unmerge the range cells into separate cells.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function unmergeRangeWithItemPath(string itemPath, string namedItemName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/unmerge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Unmerge the range cells into separate cells.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function unmergeRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/unmerge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Unmerge the range cells into separate cells.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - No Content 
    remote isolated function unmergeColumnRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/unmerge`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Clear range values such as format, fill, and border.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function clearRangeWithItemPath(string itemPath, string namedItemName, ApplyTo payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/clear`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Clear range values such as format, fill, and border.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function clearRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, ApplyTo payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/clear`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Clear range values such as format, fill, and border.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function clearColumnRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, ApplyTo payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/clear`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the cells associated with the range.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteCellWithItemPath(string itemPath, string namedItemName, Shift payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/delete`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the cells associated with the range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteCellWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, Shift payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/delete`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the cells associated with the range.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteColumnCellWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, Shift payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/delete`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Gets the range containing the single cell based on row and column numbers.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getNamedItemRangeWithRowColumnItemPath(string itemPath, string namedItemName, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range object containing the single cell based on row and column numbers.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getWorkSheetRangeWithRowAndColumnItemPath(string itemPath, string worksheetIdOrName, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range object containing the single cell based on row and column numbers.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRangeWithRowColumnAddressItemPath(string itemPath, string worksheetIdOrName, string address, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range object containing the single cell based on row and column numbers.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + row - Row number of the cell to be retrieved. Zero-indexed.
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRangeWithRowAndColumnItemPath(string itemPath, string tableIdOrName, string columnIdOrName, int row, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/cell(row=${getEncodedUri(row)},column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a column contained in the range.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRangeColumnWithItemPath(string itemPath, string namedItemName, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/column(column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a column contained in the range
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRangeColumnWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/column(column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a column contained in the range
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + column - Column number of the cell to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnRangeColumnWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, int column, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/column(column=${getEncodedUri(column)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the right of the given range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCloumAfterRangeWithItemPath(string itemPath, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/columnsAfter`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the right of the given range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + columnCount - The number of columns to include in the resulting range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCloumAfterRangeWithCountItemPath(string itemPath, string worksheetIdOrName, int columnCount, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/columnsAfter(count=${getEncodedUri(columnCount)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the left of the given range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCloumBeforeRangeWithItemPath(string itemPath, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/columnsBefore`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the left of the given range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + columnCount - The number of columns to include in the resulting range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getCloumBeforeRangeWithCountItemPath(string itemPath, string worksheetIdOrName, int columnCount, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/columnsBefore(count=${getEncodedUri(columnCount)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire column of the range.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getEntireColumnRangeWithItemPath(string itemPath, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/entireColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire column of the range
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getEntireColumnRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/entireColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire column of the range
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getColumnEntireColumnRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/entireColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire row of the range
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getEntireRowRangeWithItemPath(string itemPath, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/entireRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire row of the range
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getEntireRowRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/entireRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the range that represents the entire row of the range
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnEntireRowRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/entireRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last cell within the range.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastCellWithItemPath(string itemPath, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/lastCell`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last cell within the range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastCellWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/lastCell`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last cell within the range.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnLastCellWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/lastCell`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last column within the range
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastColumnRangeWithItemPath(string itemPath, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/lastColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last column within the range
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastColumnRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/lastColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last column within the range
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnLastColumnRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/lastColumn`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last row within the range.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastRowRangeWithItemPath(string itemPath, string namedItemName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/lastRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last row within the range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getLastRowRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/lastRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets the last row within the range.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnLastRowRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/lastRow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of rows above a given range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRowsAboveRangeWithItemPath(string itemPath, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/rowsAbove`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of rows above a given range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + rowCount - The number of rows to include in the resulting range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRowsAboveRangeWithCountItemPath(string itemPath, string worksheetIdOrName, int rowCount, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/rowsAbove(count=${getEncodedUri(rowCount)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the left of the given range
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRowsBelowRangeWithItemPath(string itemPath, string worksheetIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/rowsBelow`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Gets a certain number of columns to the left of the given range
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + rowCount - The number of rows to include in the resulting range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getRowsBelowRangeWithCountItemPath(string itemPath, string worksheetIdOrName, int rowCount, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/rowsBelow(count=${getEncodedUri(rowCount)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the used range of the given range.
    #
    # + itemPath - The full path of the workbook
    # + namedItemName - The name of the named item
    # + valuesOnly - A value indicating whether to return only the values in the used range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getUsedRangeWithItemPath(string itemPath, string namedItemName, boolean valuesOnly, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(namedItemName)}/range/usedRange(valuesOnly=${getEncodedUri(valuesOnly)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the used range of the given range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + valuesOnly - A value indicating whether to return only the values in the used range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getUsedRangeWithAddressItemPath(string itemPath, string worksheetIdOrName, string address, boolean valuesOnly, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/usedRange(valuesOnly=${getEncodedUri(valuesOnly)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the used range of the given range.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + valuesOnly - A value indicating whether to return only the values in the used range
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getColumnUsedRangeWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, boolean valuesOnly, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}/range/usedRange(valuesOnly=${getEncodedUri(valuesOnly)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the resized range of a range.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + deltaRows - The number of rows to expand or contract the bottom-right corner of the range by. If deltaRows is positive, the range will be expanded. If deltaRows is negative, the range will be contracted.
    # + deltaColumns - The number of columns to expand or contract the bottom-right corner of the range by. If deltaColumns is positive, the range will be expanded. If deltaColumns is negative, the range will be contracted.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getResizedRangeWithItemPath(string itemPath, string worksheetIdOrName, int deltaRows, int deltaColumns, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range/resizedRange(deltaRows=${getEncodedUri(deltaRows)}, deltaColumns=${getEncodedUri(deltaColumns)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        Range response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Get the range visible from a filtered range
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + address - The address
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getVisibleViewWithItemPath(string itemPath, string worksheetIdOrName, string address, string? sessionId = ()) returns RangeView|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/range(address='${getEncodedUri(address)}')/visibleView`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RangeView response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of table in the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listWorkbookTables(string itemId, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Tables|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Tables response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of table in the worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listTables(string itemId, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Tables|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Tables response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a new table in the workbook
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function createWorkbookTable(string itemId, CreateTablePayload payload, string? sessionId = ()) returns Table|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Table response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Create a new table in the worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function createTable(string itemId, string worksheetIdOrName, CreateTablePayload payload, string? sessionId = ()) returns Table|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Table response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getWorkbookTable(string itemId, string worksheetIdOrName, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Table|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Table response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Deletes the table from the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteWorkbookTable(string itemId, string worksheetIdOrName, string tableIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update the properties of table in the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateWorkbookTable(string itemId, string tableIdOrName, Table payload, string? sessionId = ()) returns Table|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Table response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the table from the worksheet
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteTable(string itemId, string worksheetIdOrName, string tableIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update the properties of table in the worksheet
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateTable(string itemId, string worksheetIdOrName, string tableIdOrName, Table payload, string? sessionId = ()) returns Table|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Table response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Get the range associated with the entire table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getWorkbookTableRange(string itemId, string tableIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the range associated with the entire table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getTableRange(string itemId, string worksheetIdOrName, string tableIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of table in the workbook.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listWorkbookTablesWithItemPath(string itemPath, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Tables|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Tables response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of table in the worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listTablesWithItemPath(string itemPath, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Tables|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Tables response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a new table in the workbook
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function createWorkbookTableWithItemPath(string itemPath, CreateTablePayload payload, string? sessionId = ()) returns Table|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Table response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Create a new table in the worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function createTableWithItemPath(string itemPath, string worksheetIdOrName, CreateTablePayload payload, string? sessionId = ()) returns Table|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Table response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of table.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getWorkbookTableWithItemPath(string itemPath, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Table|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Table response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Deletes the table from the workbook.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteWorkbookTableWithItemPath(string itemPath, string tableIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update the properties of table in the workbook.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateWorkbookTableWithItemPath(string itemPath, string tableIdOrName, Table payload, string? sessionId = ()) returns Table|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Table response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of table.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getTableWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Table|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Table response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Deletes the table from the worksheet
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteTableWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update the properties of table in the worksheet
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function updateTableWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, Table payload, string? sessionId = ()) returns Table|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Table response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Get the range associated with the entire table.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getWorkbookTableRangeWithItemPath(string itemPath, string tableIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the range associated with the entire table.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getTableRangeWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of table row in the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - Success. 
    remote isolated function listWorkbookTableRows(string itemId, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Rows|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Rows response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Adds rows to the end of a table in the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function createWorkbookTableRow(string itemId, string tableIdOrName, Row payload, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Row response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve a list of table row in the worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listTableRows(string itemId, string worksheetIdOrName, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Rows|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Rows response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Adds rows to the end of a table in the worksheet.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function createTableRow(string itemId, string worksheetIdOrName, string tableIdOrName, Row payload, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Row response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Update the properties of table row.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + rowIndex - The index of the table row
    # + sessionId - The ID of the session
    # + return - Success. 
    remote isolated function updateTableRow(string itemId, string worksheetIdOrName, string tableIdOrName, int rowIndex, Row payload, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Row response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Adds rows to the end of the table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function addTableRow(string itemId, string worksheetIdOrName, string tableIdOrName, Row payload, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Row response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Gets a row based on its position in the collection.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getTableRowWithIndex(string itemId, string worksheetIdOrName, string tableIdOrName, int index, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows/itemAt(index=${getEncodedUri(index)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Row response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Deletes the row from the workbook table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteTableRow(string itemId, string worksheetIdOrName, string tableIdOrName, int index, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows/itemAt(index=${getEncodedUri(index)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Get the range associated with the entire row.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getWorkbookTableRowRangeWithIndex(string itemId, string tableIdOrName, int index, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/rows/itemAt(index=${getEncodedUri(index)})/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the range associated with the entire row.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - Success. 
    remote isolated function getTableRowRangeWithIndex(string itemId, string worksheetIdOrName, string tableIdOrName, int index, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows/itemAt(index=${getEncodedUri(index)})/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of table row in the workbook.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - Success. 
    remote isolated function listWorkbookTableRowsWithItemPath(string itemPath, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Rows|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Rows response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Adds rows to the end of a table in the workbook.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function createWorkbookTableRowWithItemPath(string itemPath, string tableIdOrName, Row payload, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Row response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve a list of table row in the worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listTableRowsWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Rows|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Rows response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Adds rows to the end of a table in the worksheet.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function createTableRowWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, Row payload, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Row response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Update the properties of table row.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + rowIndex - The index of the table row
    # + sessionId - The ID of the session
    # + return - Success. 
    remote isolated function updateTableRowWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, int rowIndex, Row payload, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Row response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Adds rows to the end of the table.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function addTableRowWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, Row payload, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Row response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Gets a row based on its position in the collection.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getTableRowWithIndexItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, int index, string? sessionId = ()) returns Row|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows/itemAt(index=${getEncodedUri(index)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Row response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Deletes the row from the workbook table.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function deleteTableRowWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, int index, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows/itemAt(index=${getEncodedUri(index)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Get the range associated with the entire row.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function getWorkbookTableRowRangeWithIndexItemPath(string itemPath, string tableIdOrName, int index, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/rows/itemAt(index=${getEncodedUri(index)})/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get the range associated with the entire row.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - Success. 
    remote isolated function getTableRowRangeWithIndexItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, int index, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/rows/itemAt(index=${getEncodedUri(index)})/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of table column in the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listWorkbookTableColumns(string itemId, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Columns|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Columns response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a new table column in the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function createWorkBookTableColumn(string itemId, string tableIdOrName, Column payload, string? sessionId = ()) returns Column|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Column response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve a list of table column in the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function listTableColumns(string itemId, string worksheetIdOrName, string tableIdOrName, string? sessionId = ()) returns Columns[]|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/columns`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Columns[] response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a new table column in the workbook.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function createTableColumn(string itemId, string worksheetIdOrName, string tableIdOrName, Column payload, string? sessionId = ()) returns Column|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/columns`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Column response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the column from the table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - No Content. 
    remote isolated function deleteWorkbookTableColumn(string itemId, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Delete a column from a table.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - No Content. 
    remote isolated function deleteTableColumn(string itemId, string worksheetIdOrName, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Retrieve a list of table column in the workbook.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK 
    remote isolated function listWorkbookTableColumnsWithItemPath(string itemPath, string tableIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Columns|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Columns response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a new table column in the workbook.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function createWorkBookTableColumnWithItemPath(string itemPath, string tableIdOrName, Column payload, string? sessionId = ()) returns Column|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Column response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve a list of table column in the workbook.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function listTableColumnsWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, string? sessionId = ()) returns Columns|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/columns`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Columns response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a new table column in the workbook.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function createTableColumnWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, Column payload, string? sessionId = ()) returns Column|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/columns`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Column response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Deletes the column from the table.
    #
    # + itemPath - The full path of the workbook
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - No Content. 
    remote isolated function deleteWorkbookTableColumnWithItemPath(string itemPath, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Delete a column from a table.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + tableIdOrName - The ID or name of the table
    # + columnIdOrName - The ID or name of the column
    # + sessionId - The ID of the session
    # + return - No Content. 
    remote isolated function deleteTableColumnWithItemPath(string itemPath, string worksheetIdOrName, string tableIdOrName, string columnIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/tables/${getEncodedUri(tableIdOrName)}/columns/${getEncodedUri(columnIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Retrieve a list of chart.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - A collection of chart objects. 
    remote isolated function listCharts(string itemId, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Charts|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Charts response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Creates a new chart
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function addChart(string itemId, string worksheetIdOrName, CreateChartPayload payload, string? sessionId = ()) returns Chart|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Chart response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of chart.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChart(string itemId, string worksheetIdOrName, string chartIdOrName, string? sessionId = ()) returns Chart|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Chart response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Deletes the chart.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function deleteChart(string itemId, string worksheetIdOrName, string chartIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update the properties of chart.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function updateChart(string itemId, string worksheetIdOrName, string chartIdOrName, Chart payload, string? sessionId = ()) returns Chart|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Chart response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Resets the source data for the chart.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function setChartData(string itemId, string worksheetIdOrName, string chartIdOrName, ResetData payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/setData`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Positions the chart relative to cells on the worksheet
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function setPosition(string itemId, string worksheetIdOrName, string chartIdOrName, Position payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/setPosition`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve a list of chart series .
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - Created. 
    remote isolated function listChartSeries(string itemId, string worksheetIdOrName, string chartIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns CollectionOfChartSeries|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/series`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CollectionOfChartSeries response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # create a new chart series.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function createChartSeries(string itemId, string worksheetIdOrName, string chartIdOrName, ChartSeries payload, string? sessionId = ()) returns ChartSeries|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/series`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        ChartSeries response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Gets a chart based on its position in the collection.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartBasedOnPosition(string itemId, string worksheetIdOrName, int index, string? sessionId = ()) returns Chart|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/itemAt(index=${getEncodedUri(index)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Chart response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Renders the chart as a base64-encoded image by scaling the chart to fit the specified dimensions.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartImage(string itemId, string worksheetIdOrName, string chartIdOrName, string? sessionId = ()) returns Image|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/image`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Image response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Renders the chart as a base64-encoded image by scaling the chart to fit the specified dimensions.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + width - The desired width of the resulting image.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartImageWithWidth(string itemId, string worksheetIdOrName, string chartIdOrName, int width, string? sessionId = ()) returns Image|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/image(width=${getEncodedUri(width)})`;
        map<anydata> queryParam = {"width": width};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Image response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Renders the chart as a base64-encoded image by scaling the chart to fit the specified dimensions.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + width - The desired width of the resulting image.
    # + height - The desired height of the resulting image.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartImageWithWidthHeight(string itemId, string worksheetIdOrName, string chartIdOrName, int width, int height, string? sessionId = ()) returns Image|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/image(width=${getEncodedUri(width)},height=${getEncodedUri(height)})`;
        map<anydata> queryParam = {"width": width, "height": height};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Image response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Renders the chart as a base64-encoded image by scaling the chart to fit the specified dimensions.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + width - The desired width of the resulting image.
    # + height - The desired height of the resulting image.
    # + fittingMode - The method used to scale the chart to the specified dimensions (if both height and width are set)."
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartImageWithWidthHeightFittingMode(string itemId, string worksheetIdOrName, string chartIdOrName, int width, int height, "Fit"|"FitAndCenter"|"Fill" fittingMode, string? sessionId = ()) returns Image|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/image(width=${getEncodedUri(width)},height=${getEncodedUri(height)},fittingMode=${getEncodedUri(fittingMode)})`;
        map<anydata> queryParam = {"width": width, "height": height, "fittingMode": fittingMode};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Image response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of chart.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - A collection of chart objects. 
    remote isolated function listChartsWithItemPath(string itemPath, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns Charts|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Charts response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Creates a new chart
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function addChartWithItemPath(string itemPath, string worksheetIdOrName, CreateChartPayload payload, string? sessionId = ()) returns Chart|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Chart response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of chart.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartWithItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, string? sessionId = ()) returns Chart|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Chart response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Deletes the chart.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function deleteChartWithItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update the properties of chart.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function updateChartWithItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, Chart payload, string? sessionId = ()) returns Chart|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Chart response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Resets the source data for the chart.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function setChartDataWithItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, ResetData payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/setData`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Positions the chart relative to cells on the worksheet
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function setPositionWithItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, Position payload, string? sessionId = ()) returns http:Response|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/setPosition`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        http:Response response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve a list of chart series .
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - Created. 
    remote isolated function listChartSeriesWithItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns CollectionOfChartSeries|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/series`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CollectionOfChartSeries response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # create a new chart series.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function createChartSeriesWithItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, ChartSeries payload, string? sessionId = ()) returns ChartSeries|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/series`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        ChartSeries response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Gets a chart based on its position in the collection.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + index - Index value of the object to be retrieved. Zero-indexed.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartBasedOnPositionWithItemPath(string itemPath, string worksheetIdOrName, int index, string? sessionId = ()) returns Chart|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/itemAt(index=${getEncodedUri(index)})`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Chart response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Renders the chart as a base64-encoded image by scaling the chart to fit the specified dimensions.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartImageWithItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, string? sessionId = ()) returns Image|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/image`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Image response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Renders the chart as a base64-encoded image by scaling the chart to fit the specified dimensions.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + width - The desired width of the resulting image.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartImageWithWidthItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, int width, string? sessionId = ()) returns Image|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/image(width=${getEncodedUri(width)})`;
        map<anydata> queryParam = {"width": width};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Image response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Renders the chart as a base64-encoded image by scaling the chart to fit the specified dimensions.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + width - The desired width of the resulting image.
    # + height - The desired height of the resulting image.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartImageWithWidthHeightItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, int width, int height, string? sessionId = ()) returns Image|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/image(width=${getEncodedUri(width)},height=${getEncodedUri(height)})`;
        map<anydata> queryParam = {"width": width, "height": height};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Image response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Renders the chart as a base64-encoded image by scaling the chart to fit the specified dimensions.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + chartIdOrName - The ID or name of the chart
    # + width - The desired width of the resulting image.
    # + height - The desired height of the resulting image.
    # + fittingMode - The method used to scale the chart to the specified dimensions (if both height and width are set)."
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getChartImageWithWidthHeightFittingModeItemPath(string itemPath, string worksheetIdOrName, string chartIdOrName, int width, int height, "Fit"|"FitAndCenter"|"Fill" fittingMode, string? sessionId = ()) returns Image|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/charts/${getEncodedUri(chartIdOrName)}/image(width=${getEncodedUri(width)},height=${getEncodedUri(height)},fittingMode=${getEncodedUri(fittingMode)})`;
        map<anydata> queryParam = {"width": width, "height": height, "fittingMode": fittingMode};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Image response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of named item.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function listWorkbookNamedItem(string itemId, string? sessionId = ()) returns NamedItems|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        NamedItems response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Adds a new name to the collection of the given scope using the user's locale for the formula.
    #
    # + itemId - The ID of the drive containing the workbook
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function addWorkbookNamedItem(string itemId, AddNamedItemPayload payload, string? sessionId = ()) returns NamedItem|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        NamedItem response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Adds a new name to the collection of the given scope using the user's locale for the formula.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function addNamedItem(string itemId, string worksheetIdOrName, AddNamedItemPayload payload, string? sessionId = ()) returns NamedItem|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/names/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        NamedItem response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the named item.
    #
    # + itemId - The ID of the drive containing the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getWorksheetNamedItems(string itemId, string worksheetIdOrName, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns NamedItems|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/names`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        NamedItems response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the named item.
    #
    # + itemId - The ID of the drive containing the workbook
    # + name - The name of the named item to get.
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getWorkbookNamedItem(string itemId, string name, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns NamedItem|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(name)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        NamedItem response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of the named item .
    #
    # + itemId - The ID of the drive containing the workbook
    # + name - The name of the named item to get.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function updateWorkbookNamedItem(string itemId, string name, NamedItem payload, string? sessionId = ()) returns NamedItem|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(name)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        NamedItem response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the range object that is associated with the name.
    #
    # + itemId - The ID of the drive containing the workbook
    # + name - The name of the named item to get.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getNamedRange(string itemId, string name, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/items/${getEncodedUri(itemId)}/workbook/names/${getEncodedUri(name)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Retrieve a list of named item.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - OK 
    remote isolated function listWorkbookNamedItemWithItemPath(string itemPath, string? sessionId = ()) returns NamedItems|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        NamedItems response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Adds a new name to the collection of the given scope using the user's locale for the formula.
    #
    # + itemPath - The full path of the workbook
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function addWorkbookNamedItemWithItemPath(string itemPath, AddNamedItemPayload payload, string? sessionId = ()) returns NamedItem|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        NamedItem response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Adds a new name to the collection of the given scope using the user's locale for the formula.
    #
    # + itemPath - The full path of the workbook
    # + worksheetIdOrName - The ID or name of the worksheet
    # + sessionId - The ID of the session
    # + return - Created. 
    remote isolated function addNamedItemWithItemPath(string itemPath, string worksheetIdOrName, AddNamedItemPayload payload, string? sessionId = ()) returns NamedItem|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/worksheets/${getEncodedUri(worksheetIdOrName)}/names/add`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        NamedItem response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the properties and relationships of the named item.
    #
    # + itemPath - The full path of the workbook
    # + name - The name of the named item to get.
    # + sessionId - The ID of the session
    # + count - Retrieves the total count of matching resources
    # + expand - Retrieves related resources
    # + filter - Filters results
    # + format - Returns the results in the specified media format
    # + orderby - Orders results
    # + search - Returns results based on search criteria
    # + 'select - Filters properties(columns)
    # + skip - Indexes into a result set
    # + top - Sets the page size of results
    # + return - OK. 
    remote isolated function getWorkbookNamedItemWithItemPath(string itemPath, string name, string? sessionId = (), string? count = (), string? expand = (), string? filter = (), string? format = (), string? orderby = (), string? search = (), string? 'select = (), int? skip = (), int? top = ()) returns NamedItem|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(name)}`;
        map<anydata> queryParam = {"$count": count, "$expand": expand, "$filter": filter, "$format": format, "$orderby": orderby, "$search": search, "$select": 'select, "$skip": skip, "$top": top};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        NamedItem response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update the properties of the named item .
    #
    # + itemPath - The full path of the workbook
    # + name - The name of the named item to get.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function updateWorkbookNamedItemWithItemPath(string itemPath, string name, NamedItem payload, string? sessionId = ()) returns NamedItem|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(name)}`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        NamedItem response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Retrieve the range object that is associated with the name.
    #
    # + itemPath - The full path of the workbook
    # + name - The name of the named item to get.
    # + sessionId - The ID of the session
    # + return - OK. 
    remote isolated function getNamedRangeWithItemPath(string itemPath, string name, string? sessionId = ()) returns Range|error {
        string resourcePath = string `/me/drive/root:/${getEncodedUri(itemPath)}:/workbook/names/${getEncodedUri(name)}/range`;
        map<any> headerValues = {"sessionId": sessionId};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Range response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
}
